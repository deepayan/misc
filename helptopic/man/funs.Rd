\name{does_not_matter}
\alias{fun1}
\alias{fun2}
\title{ Help system links }
\description{
  Examples of help system links that need to be handled carefully if we
  change the current lookup order.
}
\usage{
fun1(x, ...)
fun2(x, ...)
}
\arguments{
  \item{x}{An object.}
  \item{\dots}{Extra arguments.}
}
\details{

  This file documents a proposed change to the lookup rule in R's
  dynamic HTML help system, and identifies existing links on CRAN that
  will need to be updated to continue working as intended. It is also
  meant to serve as a source of test cases for the proposed change.

  The source of this documentation can be found at
  \url{https://github.com/deepayan/misc/blob/master/helptopic/man/funs.Rd}

}
\section{Current status}{

  The R help system includes a concept of hyperlinks to other help
  pages. Such hyperlinks are supported to a limited extent in PDF (e.g.,
  within-package links in the manual) and to a greater extent in HTML
  help.

  For potential problems with within-package links, see
  \code{\link{fun3}}.  This discussion is limited to links to
  \emph{other} packages. These come in two forms:

  \itemize{
    \item \code{\\link[pkg:foo]{link-text}}, and
    \item \code{\\link[pkg]{foo}} equivalent to \code{\\link[pkg:foo]{foo}}
  }

  Here \code{pkg} is the target package, and \code{foo} has historically
  been documented to be interpreted as a \emph{file} link; i.e., both
  links above are supposed to go to the file corresponding to
  \code{pkg/man/foo.Rd}.  The explicit file specification is needed
  because R manual pages often document multiple objects; e.g.,
  \code{grid/man/grid.rect.Rd} documents both \code{grid.rect} and
  \code{rectGrob}, so

  \itemize{

    \item \code{\\link[grid]{grid.rect}} is fine:
    \code{\link[grid]{grid.rect}} links to \code{grid.rect.html},

    \item \code{\\link[grid]{rectGrob}} will fail (for static HTML)
    because the file \code{rectGrob.html} does not exist:
    \code{\link[grid]{rectGrob}},

    \item \code{\\link[grid:rectGrob]{rectGrob}} will also fail (for
    static HTML) because it is equivalent to the previous link:
    \code{\link[grid:rectGrob]{rectGrob}},

    \item \code{\\link[grid:grid.rect]{rectGrob}} is fine:
    \code{\link[grid:grid.rect]{rectGrob}} links to
    \code{grid.rect.html}.

  }
  
  In R 2.10.0 or thereabouts, a new dynamic help system was introduced
  to enable features not possible in static HTML files, such as the
  ability to include content generated dynamically at the time of
  rendering the page. This new system also modified the interpretation
  for \code{\\link[pkg:foo]{link-text}}:

  \itemize{

    \item If the file \code{pkg/man/foo.Rd} exists, it would link to
    the corresponding HTML file \code{foo.html}.

    \item However, if this file \emph{does not} exist, it would link to
    the file containing the \emph{topic} \code{foo} (i.e.,
    \code{\\alias{foo}}).

    \item However, the link URL continues to be of the form
    \code{foo.html} in either case.

  }

  Note that this means that the link to be embedded in the HTML file
  being rendered \emph{does not} need to know anything about the target
  package \pkg{pkg}, and in particular, whether the link will at all be
  resolved. The actual lookup will happen only when the user clicks on
  the link, and may fail if the target package is not installed or the
  file / topic does not exist in it.

  This also means that the links in the generated HTML is the same for
  both static and dynamic help, but in the latter case a \code{foo.html}
  link is resolved to \emph{first} display the help page generated by
  \code{man/foo.Rd} if it exists, and \emph{then} to display the help
  page generated by \code{man/bar.Rd} if \code{man/bar.Rd} contains
  \code{\\alias{foo}}.

  This can be verified by following the \pkg{grid} links above and
  checking the URL shown (through dynamic help).

  It is possible, in principle, for multiple help pages, say
  \code{man/bar.Rd} and \code{man/baz.Rd}, to contain
  \code{\\alias{foo}}. Such packages can be installed (e.g., \code{fun1}
  is an alias both in this page and in \code{\link{fun3}}), but \code{R
  CMD check} will produce a WARNING, so such packages will not get on
  CRAN. Such a link will resolve to one of the two pages, but we do not
  really care which one.
}

\section{Fixing static pages}{

  In the current setup, one infelicity is that non-file links do not
  work with static HTML pages. To solve this without changing the
  generated HTML in any way, we must have a \code{topic.html} file
  available for every topic (alias) in a package. This can be done
  easily by creating small one-line HTTP redirect files pointing to the
  actual target file while processing the package man files.

  To ensure that filenames get priority over topics, we only need to
  ensure that

  \itemize{

    \item topic redirect files do not overwrite an existing (primary)
    file of the same name

    \item primary files (\code{foo.Rd -> foo.html}) \emph{do} overwrite
    existing (topic) files of the same name.

  }

}

\section{Going further --- prefer topic over filename}{

  Although file links are natural with traditional hyperlinks, for the R
  help system it is more natural to link to topics rather than
  filenames. There is a general consensus that we should move to a
  system where \code{\\link[pkg:foo]{link-text}} should be interpreted
  as a link to the \emph{topic} foo in package \pkg{pkg}, regardless of
  whether there is a file called \code{man/foo.Rd} in it. In fact, there
  are many instances of packages on CRAN where this interpretation has
  been assumed, because of the support for topic links in the dynamic
  help system (such links do not currently work with static HTML).

  Implementing this should not be difficult, but unfortunately,
  switching completely to a topic-only lookup rule would be unfair to
  careful package authors who have intentionally linked to files. So the
  proposal is only to \emph{prefer} topics and fall back to files when
  the topic does not exist.
  
  This still leaves open the possibility of penalizing careful package
  authors under certain special circumstances; namely, the package
  \pkg{pkg} has a file \code{foo.Rd}, as well as a topic
  \code{\\alias{foo}} but in a \emph{different} file \code{bar.Rd}. In
  such cases, a link like \code{\\link[pkg:foo]{link-text}} would change
  meaning; from being a link to \code{foo.Rd} it will become a link to
  \code{bar.Rd}.

  The example code below finds instances of such occurrences on CRAN
  (yielding 79 such packages). Fortunately, in all these cases, the name
  of the file (\code{bar.Rd}) is not an alias in the package (i.e.,
  there is no \code{\\alias{bar}}), so links of the form
  \code{\\link[pkg:bar]{link-text}} would unambiguously link to
  \code{bar.Rd}.

  This is still not a problem unless there are \emph{other} packages
  that actually link to one of these ambiguous topic / file
  pairs. Pattern matching leads to the following extant examples, which
  we need to analyze. Fortunately, there are not many packages that
  potentially need fixing, but we do need to find a resolution that will
  work both in pre- and post-change versions of R.

  The examples are organized by target package.

}


\section{\pkg{adegenet}}{

  Topic \code{genind} is documented in file \code{new.genind.Rd}. File
  \code{genind.Rd} documents \code{genind-class} and other related methods.

  Topic \code{genpop} is documented in file \code{new.genind.Rd}. File
  \code{genpop.Rd} documents \code{genpop-class} and other related methods.

  The following packages link to either of these (\code{genind.Rd} and
  \code{genpop.Rd}):

  \itemize{
  
    \item EcoGenetics/man/EcoGenetics-package.Rd: Conversion to and from
    \link[adegenet]{genpop} is defined.

    \item pegas/man/conversion.Rd: \code{\link[adegenet]{genind}},

    \item poppr/man/make_haplotypes-method.Rd: \link[adegenet:genind]{genind} object.

    \item popprxl/man/read.genalexcel.Rd: \code{\link[adegenet]{genind}}

    \item poppr/man/aboot.Rd: \code{\link[adegenet:genind]{adegenet::genind()}}

    \item poppr/man/aboot.Rd: \code{\link[adegenet:genpop]{adegenet::genpop()}}
    with the specified strata.

  }

  All these currently link to the class page and not the function
  page. This is probably as intended in several cases, although probably
  not in at least the last two examples. Under the new proposal, these
  will link to the function page.

  Links of the following form should work both under the current and
  proposed rules:

  \itemize{

    \item For the \link[adegenet:genind-class]{class page}:
    \code{\\link[adegenet:genind-class]{link-text}}

    \item For the \link[adegenet:new.genind]{function page}:
    \code{\\link[adegenet:new.genind]{link-text}}


  }

  
}



\section{\pkg{callr}}{

  The following instances of \code{\\link[callr:rcmd_safe]} both
  currently link to the topic \code{rcmd_safe_env} in
  \code{rcmd_safe.Rd}, which is likely not intended. The topic
  \code{rcmd_safe} is documented in file \code{rcmd.Rd}.
  
  \itemize{

    \item fakemake/man/check_archive.Rd:
    \code{\link[callr:rcmd_safe]{callr::rcmd_safe}("check")},

    \item pkgbuild/man/rcmd_build_tools.Rd: wrapper around
    \code{\link[callr:rcmd_safe]{callr::rcmd_safe()}}

  }

  These will work as intended under the proposed scheme, so probably
  best to leave them alone. Alternatively, change
  \code{\link[callr:rcmd_safe]{\\link[callr:rcmd_safe]\{link-text\}}} to
  \code{\link[callr:rcmd]{\\link[callr:rcmd]\{link-text\}}}.

}


\section{\pkg{lamW}}{

  The file \code{lamW.Rd} documents several functions, whereas the topic
  \code{lamW} is documented in file \code{lamW-package.Rd}. So the
  following links are all explicit and correct file links that will stop
  working in the proposed scheme.

  \itemize{
  
    \item LambertW/man/W.Rd: \code{\link[lamW:lamW]{lambertW0_C}} and

    \item LambertW/man/W.Rd: \code{\link[lamW:lamW]{lambertWm1_C}} in
    the \pkg{lamW} package

    \item LambertW/man/W.Rd:\code{W} is a wrapper for
    \code{\link[lamW:lamW]{lambert_W0C}}

    \item LambertW/man/W.Rd: \code{\link[lamW:lamW]{lambert_Wm1_C}} in
    the \pkg{lamW} package.

    \item LambertW/man/W.Rd: \code{\link[lamW:lamW]{lambertW0_C}} and

    \item LambertW/man/W.Rd: \code{\link[lamW:lamW]{lambertWm1_C}} in
    the \pkg{lamW} package;

  }

  A fix that should work under both current and proposed schemes is to
  change \code{\\link[lamW:lamW]{lambertW0_C}} to the simpler (and more
  correct) \code{\link[lamW:lambertW0]{\\link[lamW]\{lambertW0\}}},
  etc. (\code{lambertW0_C} is an internal function, not supposed to be
  user-callable, and not documented in \code{lamW.Rd}). Unfortunately,
  this will no longer work for static pages in the current scheme, but
  that is hopefully a minor consideration.
  
}


\section{\pkg{parsnip}}{

  The only problematic link here is topic \code{fit} which is documented
  in file \code{reexports.Rd} (as a rexported generic), while the file
  \code{fit.Rd} documents the S3 method \code{fit.model_spec}. For the
  links below that have the form \code{\\link[parsnip:fit]{link-text}},  the
  intent is almost certainly to link to \code{fit.Rd}, as the links
  below currently do, but that will change under the proposed scheme.

  \itemize{

    \item rules/man/C5_rules.Rd:converted to numeric indicator
    values. Note that using \code{\link[parsnip:fit]{parsnip::fit()}}
    will

    \item rules/man/C5_rules.Rd:
    \code{\link[parsnip:fit]{parsnip::fit()}},
    \code{\link[parsnip:fit_xy]{parsnip::fit_xy()}}, ...

    \item rules/man/cubist_rules.Rd: Note that using
    \code{\link[parsnip:fit]{parsnip::fit()}} will

    \item rules/man/cubist_rules.Rd:
    \code{\link[parsnip:fit]{parsnip::fit()}},
    \code{\link[parsnip:fit_xy]{parsnip::fit_xy()}}, ...
    
    \item rules/man/rule_fit.Rd:
    \code{\link[parsnip:fit]{parsnip::fit()}},
    \code{\link[parsnip:fit_xy]{parsnip::fit_xy()}}, ...

    \item workflows/man/fit-workflow.Rd: using
    \code{\link[parsnip:fit]{parsnip::fit.model_spec()}}

  }

  A fix that would work with both current and proposed schemes would be
  change to links of the form
  \code{\link[parsnip:fit.model_spec]{\\link[parsnip:fit.model_spec]\{link-text\}}}.
  
}

\section{\pkg{perm}}{

  Here the file \code{perm.Rd} documents topics \code{permTS},
  \code{permKS}, etc., and the topic \code{perm} is in file
  \code{perm-package.Rd}.

  \itemize{
  
    \item FHtest/man/FHtesticp.Rd: see details in \link[perm]{perm}

    \item interval/man/ictest.Rd: see details in \code{\link[perm]{perm}}

    \item interval/man/ictest.Rd: see \code{\link[perm]{perm}}

  }

  The links (all \code{\\link[perm]{perm}}) above currently link to the
  file, which is likely as intended. To continue this in a
  back-compatible manner, they should be changed to
  \code{\link[perm:permTS]{\\link[perm:permTS]\{perm\}}}.
  
}

\section{\pkg{spaMM}}{

  The file \code{Matern.corr.Rd} documents topic \code{MaternCorr},
  while the topic \code{Matern.corr} is an alias in
  \code{spaMM-internal.Rd}. The link

  \itemize{
    
    \item IsoriX/man/isofit.Rd: \code{\link[spaMM]{Matern.corr}} for information

  }

  is likely meant to be to the file \code{Matern.corr.Rd}, and so should
  be changed to
  \code{\link[spaMM:MaternCorr]{\\link[spaMM:MaternCorr]\{Matern.corr\}}},
  or probably more appropriately and simply, to
  \code{\link[spaMM:MaternCorr]{\\link[spaMM]\{MaternCorr\}}}.

}


\examples{

a <- tools:::CRAN_aliases_db()
fun <- function(e) {
    files <- tools::file_path_sans_ext(names(e))
    topics <- Map(setdiff, e, files)
    intersect(files, unlist(topics))
}
z <- lapply(a, fun)
z <- Filter(length, z)

ambiguousTopics <- function(pkg)
{
    ## filenames which are also topics in a different file
    files <- z[[pkg]]
    ## which file the corresponding topic is in
    otherfiles <- character(length(files))
    for (i in seq_along(files))
    {
        otherfiles[i] <-
            names(which(sapply(a[[pkg]], function(x) files[i] \%in\% x)))
    }
    ## Is 'otherfile' also a topic somewhere in the package?
    also_topic <- otherfiles \%in\% unlist(a[[pkg]])
    data.frame(pkg = pkg, file = files, topicfile = otherfiles,
               also_topic = also_topic)
}

options(width = 120)
do.call(rbind, lapply(names(z), ambiguousTopics))

}
\keyword{documentation}


