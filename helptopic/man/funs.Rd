\name{does_not_matter}
\alias{fun1}
\alias{fun2}
\title{ Help system links }
\description{
  Examples of help system links that need to be handled carefully if we
  change the current lookup order.
}
\usage{
fun1(x, ...)
fun2(x, ...)
}
\arguments{
  \item{x}{An object.}
  \item{\dots}{Extra arguments.}
}
\section{Current status}{

  The R help system includes a concept of hyperlinks to other help
  pages. Such hyperlinks are supported to a limited extent in PDF (e.g.,
  within-package links in the manual) and to a greater extent in HTML
  help.

  For potential problems with within-package links, see
  \code{\link{fun3}}.  This discussion is limited to links to
  \emph{other} packages. These come in two forms:

  \itemize{
    \item \code{\\link[pkg:foo]{link-text}}, and
    \item \code{\\link[pkg]{foo}} equivalent to \code{\\link[pkg:foo]{foo}}
  }

  Here \code{pkg} is the target package, and \code{foo} has historically
  been documented to be interpreted as a \emph{file} link; i.e., both
  links above are supposed to go to the file corresponding to
  \code{pkg/man/foo.Rd}.  The explicit file specification is needed
  because R manual pages often document multiple objects; e.g.,
  \code{grid/man/grid.rect.Rd} documents both \code{grid.rect} and
  \code{rectGrob}, so

  \itemize{

    \item \code{\\link[grid]{grid.rect}} is fine:
    \code{\link[grid]{grid.rect}} links to \code{grid.rect.html},

    \item \code{\\link[grid]{rectGrob}} will fail (for static HTML)
    because the file \code{rectGrob.html} does not exist:
    \code{\link[grid]{rectGrob}},

    \item \code{\\link[grid:rectGrob]{rectGrob}} will also fail (for
    static HTML) because it is equivalent to the previous link:
    \code{\link[grid:rectGrob]{rectGrob}},

    \item \code{\\link[grid:grid.rect]{rectGrob}} is fine:
    \code{\link[grid:grid.rect]{rectGrob}} links to
    \code{grid.rect.html}.

  }
  
  Since R 2.10.0 or thereabouts, a new dynamic help system was
  introduced to enable features not possible in static HTML files, such
  as the ability to include content generated dynamically at the time of
  rendering the page. This new system also modified the interpretation
  for \code{\\link[pkg:foo]{link-text}}:

  \itemize{

    \item If the file \code{pkg/man/foo.Rd} exists, it would link to
    that file.

    \item However, if this file \emph{does not} exist, it would link to
    the file containing the \emph{topic} (\code{\\alias{}}) \code{foo}.

    \item However, the link URL continues to be of the form
    \code{foo.html} in either case.

  }

  Note that this means that the link to be embedded in the HTML file
  being rendered \emph{does not} need to know anything about the target
  package \pkg{pkg}, and in particular, whether the link will at all be
  resolved. The actual lookup will happen only when the user clicks on
  the link, and may fail if the target package is not installed or the
  file / topic does not exist in it.

  This also means that the links in the generated HTML is the same for
  both static and dynamic help, but in the latter case a \code{foo.html}
  link is resolved to \emph{first} display the help page generated by
  \code{man/foo.Rd} if it exists, and \emph{then} to display the help
  page generated by \code{man/bar.Rd} if \code{man/bar.Rd} contains
  \code{\\alias{foo}}.

  This can be verified by following the \pkg{grid} links above and
  checking the URL shown (through dynamic help).

  It is possible, in principle, for multiple help pages, say
  \code{man/bar.Rd} and \code{man/baz.Rd}, to contain
  \code{\\alias{foo}}. Such packages can be installed (e.g., \code{fun1}
  is an alias both in this page and in \code{\link{fun3}}), but \code{R
  CMD check} will produce a WARNING, so such packages will not get on
  CRAN. Such a link will resolve to one of the two pages, but we do not
  really care which one.
}

\section{Fixing static pages}{

  In the current setup, one infelicity is that non-file links do not
  work with static HTML pages. To solve this without changing the
  generated HTML in any way, we must have a \code{topic.html} file
  available for every topic (alias) in a package. This can be done
  easily by creating small one-line HTTP redirect files pointing to the
  actual target file.

  To ensure that filenames get priority over topics, we only need to
  ensure that

  \itemize{

    \item topic redirect files do not overwrite an existing (primary)
    file of the same name

    \item primary files (\code{foo.Rd -> foo.html}) \emph{do} overwrite
    existing (topic) files of the same name.

  }

}

\section{Going further --- prefer topic over filename}{

  Although file links are natural with traditional hyperlinks, for the R
  help system it is more natural to link to topics rather than
  filenames. There is a general consensus that we should move to a
  system where \code{\\link[pkg:foo]{link-text}} should be interpreted
  as a link to the \emph{topic} foo in package \pkg{pkg}, regardless of
  whether there is a file called \code{man/foo.Rd} in it. In fact, there
  are many instances of packages on CRAN where this interpretation has
  been assumed, because of the support for topic links in the dynamic
  help system (such links do not currently work with static HTML).
  
  Unfortunately, switching completely to a topic-only lookup rule would
  be unfair to careful package authors who have intentionally linked to
  files. So the proposal is only to \emph{prefer} topics and fall back
  to files when they do not exist.
  
  This still leaves open the possibility of penalizing careful package
  authors under certain special circumstances; namely, the package
  \pkg{pkg} has a file \code{foo.Rd}, as well as a topic
  \code{\\alias{foo}} but in a \emph{different} file. The example code
  below finds instances of such occurrences on CRAN (there are 79 such
  packages).

  This is still not a problem unless there are \emph{other} packages
  that actually link to one of these ambiguous topic / file
  pairs. Pattern matching leads to the following extant examples, which
  we need to analyze. Fortunately, there are not many packages that
  potentially need fixing, but we do need to find a resolution that will
  work both in pre- and post-change versions of R.
  

 
  EcoGenetics/man/EcoGenetics-package.Rd: Conversion to and from
  \link[adegenet]{genpop} is defined.

  fakemake/man/check_archive.Rd: \code{\link[callr:rcmd_safe]{callr::rcmd_safe}("check")},

  FHtest/man/FHtesticp.Rd: see details in \link[perm]{perm}

  interval/man/ictest.Rd: see details in \code{\link[perm]{perm}}

  interval/man/ictest.Rd: see \code{\link[perm]{perm}}

  IsoriX/man/isofit.Rd: \code{\link[spaMM]{Matern.corr}} for information

  LambertW/man/W.Rd: \code{\link[lamW:lamW]{lambertW0_C}} and 

  LambertW/man/W.Rd: \code{\link[lamW:lamW]{lambertWm1_C}} in the
  \pkg{lamW} package

  LambertW/man/W.Rd:\code{W} is a wrapper for \code{\link[lamW:lamW]{lambert_W0C}} 

  LambertW/man/W.Rd: \code{\link[lamW:lamW]{lambert_Wm1_C}} in the \pkg{lamW} package.

  LambertW/man/W.Rd: \code{\link[lamW:lamW]{lambertW0_C}} and

  LambertW/man/W.Rd: \code{\link[lamW:lamW]{lambertWm1_C}} in the
  \pkg{lamW} package;

  pegas/man/conversion.Rd: \code{\link[adegenet]{genind}},

  pkgbuild/man/rcmd_build_tools.Rd: wrapper around
  \code{\link[callr:rcmd_safe]{callr::rcmd_safe()}}

  poppr/man/aboot.Rd: \code{\link[adegenet:genind]{adegenet::genind()}}

  poppr/man/aboot.Rd: \code{\link[adegenet:genpop]{adegenet::genpop()}}
  with the specified strata.

  poppr/man/make_haplotypes-method.Rd: \link[adegenet:genind]{genind} or
  \link[adegenet:genlight]{genlight} object.

  popprxl/man/read.genalexcel.Rd:a \code{\link[poppr]{genclone}} or
  \code{\link[adegenet]{genind}}

  rules/man/C5_rules.Rd:converted to numeric indicator values. Note that
  using \code{\link[parsnip:fit]{parsnip::fit()}} will

  rules/man/C5_rules.Rd:\code{\link[parsnip:fit]{parsnip::fit()}},
  \code{\link[parsnip:fit_xy]{parsnip::fit_xy()}},
  \code{\link[C50:C5.0]{C50::C5.0()}},

  rules/man/cubist_rules.Rd:converted to numeric indicator values. Note
  that using \code{\link[parsnip:fit]{parsnip::fit()}} will

  rules/man/cubist_rules.Rd:\code{\link[parsnip:fit]{parsnip::fit()}},
  \code{\link[parsnip:fit_xy]{parsnip::fit_xy()}},
  \code{\link[Cubist:cubist]{Cubist::cubist()}},

  rules/man/rule_fit.Rd: \code{\link[parsnip:fit]{parsnip::fit()}},
  \code{\link[parsnip:fit_xy]{parsnip::fit_xy()}},
  \code{\link[xrf:xrf.formula]{xrf::xrf.formula()}}

  workflows/man/fit-workflow.Rd: using
  \code{\link[parsnip:fit]{parsnip::fit.model_spec()}}
}
\examples{

a <- tools:::CRAN_aliases_db()
fun <- function(e) {
    files <- tools::file_path_sans_ext(names(e))
    topics <- Map(setdiff, e, files)
    intersect(files, unlist(topics))
}
z <- lapply(a, fun)
z <- Filter(length, z)

ambiguousTopics <- function(pkg)
{
    ## filenames which are also topics in a different file
    files <- z[[pkg]]
    ## which file the corresponding topic is in
    otherfiles <- character(length(files))
    for (i in seq_along(files))
    {
        otherfiles[i] <-
            names(which(sapply(a[[pkg]], function(x) files[i] %in% x)))
    }
    ## Is 'otherfile' also a topic somewhere in the package?
    also_topic <- otherfiles %in% unlist(a[[pkg]])
    data.frame(pkg = pkg, file = files, topicfile = otherfiles,
               also_topic = also_topic)
}

options(width = 120)
do.call(rbind, lapply(names(z), ambiguousTopics))

}
\keyword{documentation}


